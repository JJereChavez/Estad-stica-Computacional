for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
# Cada agente hace como máximo 1 acción en esta ronda
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A (prioridad)
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
next  # pasa al siguiente agente
}
# --- Regla B (si no pudo usar Regla A)
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
}
}
# Si no hay más posibilidad de producir chupetines y nadie tiene chupetines para la Regla B → paro
posibles <- sapply(agentes, puede_chupetin)
if(chupetines_total < max_chupetines && !any(posibles) && sum(chupetines_agente) == 0) {
break
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
# Cada agente hace como máximo 1 acción en esta ronda
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A (prioridad)
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
next  # pasa al siguiente agente
}
# --- Regla B (si no pudo usar Regla A)
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
}
}
# Si no hay más posibilidad de producir chupetines y nadie tiene chupetines para la Regla B → paro
posibles <- sapply(agentes, puede_chupetin)
if(chupetines_total < max_chupetines && !any(posibles) && sum(chupetines_agente) == 0) {
break
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
# Cada agente hace como máximo 1 acción en esta ronda
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A (prioridad)
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
next  # pasa al siguiente agente
}
# --- Regla B (si no pudo usar Regla A)
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
}
}
# Si no hay más posibilidad de producir chupetines y nadie tiene chupetines para la Regla B → paro
posibles <- sapply(agentes, puede_chupetin)
if(chupetines_total < max_chupetines && !any(posibles) && sum(chupetines_agente) == 0) {
break
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A: solo 1 chupetín por agente en esta ronda
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
next
}
# --- Regla B: 1 vez máximo en la ronda
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
}
# Si no hubo ningún cambio y no se alcanzó el objetivo, se detiene
if(!cambio) break
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A: solo 1 chupetín por agente en esta ronda
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
next
}
# --- Regla B: 1 vez máximo en la ronda
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
}
# Si no hubo ningún cambio y no se alcanzó el objetivo, se detiene
if(!cambio) break
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
for(i in 1:n_agentes) {
if(chupetines_total >= max_chupetines) break
# --- Regla A: solo 1 chupetín por agente en esta ronda
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
next
}
# --- Regla B: 1 vez máximo en la ronda
if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
}
# Si no hubo ningún cambio y no se alcanzó el objetivo, se detiene
if(!cambio) break
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos aleatorios
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
# Escoger un agente al azar para actuar en esta ronda
i <- sample(1:n_agentes, 1)
# --- Regla A: si tiene A, C, N
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
} else if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
# --- Regla B
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
if(!cambio) {
# Si en esta iteración no pasó nada, seguimos igual
# Esto evita que el while se trabe
next
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos aleatorios
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
# Escoger un agente al azar para actuar en esta ronda
i <- sample(1:n_agentes, 1)
# --- Regla A: si tiene A, C, N
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
} else if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
# --- Regla B
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
if(!cambio) {
# Si en esta iteración no pasó nada, seguimos igual
# Esto evita que el while se trabe
next
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos aleatorios
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
# Escoger un agente al azar para actuar en esta ronda
i <- sample(1:n_agentes, 1)
# --- Regla A: si tiene A, C, N
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
} else if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
# --- Regla B
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
if(!cambio) {
# Si en esta iteración no pasó nada, seguimos igual
# Esto evita que el while se trabe
next
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos aleatorios
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
# Escoger un agente al azar para actuar en esta ronda
i <- sample(1:n_agentes, 1)
# --- Regla A: si tiene A, C, N
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
} else if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
# --- Regla B
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
if(!cambio) {
# Si en esta iteración no pasó nada, seguimos igual
# Esto evita que el while se trabe
next
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
set.seed(123)
colores <- c("A","C","N")
n_agentes <- 18
# Inicializar agentes con 6 caramelos aleatorios
agentes <- vector("list", n_agentes)
for(i in 1:n_agentes) {
agentes[[i]] <- sample(colores, 6, replace = TRUE)
}
chupetines_agente <- rep(0, n_agentes)
puede_chupetin <- function(caramelos) {
all(c("A","C","N") %in% caramelos)
}
max_chupetines <- 10
chupetines_total <- 0
iteraciones <- 0
while(chupetines_total < max_chupetines) {
iteraciones <- iteraciones + 1
cambio <- FALSE
# Escoger un agente al azar para actuar en esta ronda
i <- sample(1:n_agentes, 1)
# --- Regla A: si tiene A, C, N
if(puede_chupetin(agentes[[i]])) {
for(col in c("A","C","N")) {
idx <- match(col, agentes[[i]])
if(!is.na(idx)) agentes[[i]] <- agentes[[i]][-idx]
}
chupetines_agente[i] <- chupetines_agente[i] + 1
chupetines_total <- chupetines_total + 1
cambio <- TRUE
} else if(chupetines_agente[i] > 0 && length(agentes[[i]]) > 0) {
# --- Regla B
chupetines_agente[i] <- chupetines_agente[i] - 1
agentes[[i]] <- agentes[[i]][-1]
nuevos <- sample(colores, 4, replace = TRUE)
agentes[[i]] <- c(agentes[[i]], nuevos)
cambio <- TRUE
}
if(!cambio) {
# Si en esta iteración no pasó nada, seguimos igual
# Esto evita que el while se trabe
next
}
}
cat("Chupetines generados:", chupetines_total, "\n")
cat("Iteraciones necesarias:", iteraciones, "\n")
install.packages(c("shiny", "FactoMineR", "factoextra", "ggplot2", "DT", "shinythemes"))
shiny::runApp('C:/Users/HP/Downloads/Estadistica Computacionañl/shiny r/EstComputacional')
runApp('C:/Users/HP/Downloads/Estadistica Computacionañl/shiny r/EstComputacional')
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("FactoMineR")
install.packages("FactoMineR")
library(FactoMineR)
data(tea)
head(tea)
library(FactoMineR)
data(tea)
head(tea)
install.packages(c("shiny", "FactoMineR", "factoextra", "ggplot2", "DT", "shinythemes"))
install.packages(c("shiny", "FactoMineR", "factoextra", "ggplot2", "DT", "shinythemes"))
shiny::runApp()
